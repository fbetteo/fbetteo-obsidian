# SSH

>https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys


Lo entiendo como un mecanismo para validar la identidad de una computadora particular en vez de usar password que es más vulnerable. La lógica es primero generar un par de keys, privada (*id_rsa*) y pública (*id_rsa.pub*) mediante:

```
ssh-keygen
``` 
desde la terminal/cmd/powershell.
Eso queda guardado en la computadora. Depende el SO puede quedar dentro de Users(windows) o en la root de Linux (generalmente, se puede cambiar pero dejar lo de default es lo mas conveniente).

Por otra parte el servidor al que uno quiere conectarse va a tener que tener nuestra public key almacenada en archivo *authorized_keys*. Eso va a permitir que cuando querramos conectarnos con ssh, identifique que nuestra computadora tiene una public key válida.

Si un mismo usuario quiere acceder desde distintas computadoras con SSH (ej: github) lo recomendado es generar un nuevo par de keys por cada computadora y agregar la pública al servidor. Se recomienda no copiar private keys entre computadoras (aunque funcione) porque es como usar la misma pass para varias cosas.

El proceso luego es que el servidor envía un mensaje encriptado mediante la public key que solo puede desencriptarse con la private key.
>When a client connects to the host, wishing to use SSH key authentication, it will inform the server of this intent and will tell the server which public key to use. The server then checks its `authorized_keys` file for the public key, generates a random string, and encrypts it using the public key. This encrypted message can only be decrypted with the associated private key. The server will send this encrypted message to the client to test whether they actually have the associated private key.
Upon receipt of this message, the client will decrypt it using the private key and combine the random string that is revealed with a previously negotiated session ID. It then generates an MD5 hash of this value and transmits it back to the server. The server already had the original message and the session ID, so it can compare an MD5 hash generated by those values and determine that the client must have the private key.